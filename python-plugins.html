<!DOCTYPE html>
<html lang="es">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE-edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

			<meta name="author" content="Antonio Ramirez" />
		
		
		
		<title>Plugins en Python  - Python Granada
</title>
		
  			<link rel="stylesheet" href="https://pythongranada.github.io/blog/theme/css/style.min.css?3e58e027">
		
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
		<script src="https://pythongranada.github.io/blog/theme/js/menu.js"></script>

	</head>
	<body>

<nav class="navbar is-primary" role="navigation" aria-label="main navigation">
    <div class="navbar-brand">
            <a class="navbar-item" href="https://pythongranada.github.io/blog">
                <img src="https://pythongranada.github.io/blog/theme/images/logo_grande.svg">
            </a>
        <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarMain">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
    </div>
    <div id="navbarMain" class="navbar-menu">
        <div class="navbar-start">
            <a class="navbar-item" href="https://pythongranada.github.io/blog/pages/about.html">
                Asociaci칩n
            </a>
            <div class="navbar-item has-dropdown is-hoverable">
                <a class="navbar-link" href="https://pythongranada.github.io/blog/categories">
Categorias                </a>
                <div class="navbar-dropdown">
                    <a class="navbar-item" href="https://pythongranada.github.io/blog/category/blog.html">
                        Blog
                    </a>
                </div>
            </div>
    </div>
    <div class="navbar-end">
        <div class="navbar-item">
            <div class="buttons">
            </div>
        </div>
    </div>
</div>
</nav>
		<section class="section">
			<div class="container">
<article class="message is-info">
	<div class="message-header">
		<h2>Plugins en Python</h2>
		<p><time itemprop="dateCreated" datetime="2021-06-01T10:20:00+02:00">Tue 01 June 2021</time></p>
	</div>
	<div class="message-body has-text-dark">
		<p>Vamos a proponer un peque침o caso de uso. Supongamos estamos trabajando en un programa que necesita generar una serie de gr치ficas. Para poder generar estas gr치ficas, debemos de acceder a una base de datos y desde ah칤, recuperar un conjunto de datos, agruparlos seg칰n un criterio temporal (por ejemplo, d칤as u horas),
y adem치s, en algunos casos, realizar transformaciones sobre esos datos para generar otros datos.</p>
<p>En principio, no parece demasiado complicado, 쯨erdad? Incluso podemos parametrizar parcialmente los datos que vamos a utilizar de entrada (por ejemplo, los periodos temporales). Pero, <strong>쯤u칠 ocurre cuando las bases de datos por debajo cambian?</strong> Si cambia la nomenclatura de las tablas, o las relaciones entre ellas, o incluso pasamos de trabajar con bases de datos a hojas de c치lculo EXCEL...</p>
<p>En algunos casos la soluci칩n puede ser sencilla, como por ejemplo crear una peque침a base de datos para volcar los datos del EXCEL y trabajar con ella; en otros, quiz치s tengamos que modificar el core de nuestra librer칤a para cambiar la forma en que se recuperan los datos. Pero, <strong>쯤u칠 pasar칤a si las soluciones deben de coexistir entre ellas?</strong> Lo m치s probable es que terminemos con una capa de c칩digo intermedia dedicada a la selecci칩n de los mecanismos de generaci칩n de gr치ficas, y luego un conjunto de librer칤as, funciones o clases que lleven a cabo el duro trabajo de lidiar con las capas inferiores.</p>
<p>Aqu칤 se plantea otro problema adicional: si utilizamos la misma base de c칩digo para generar todos estos mecanismos, tendremos problemas para paralelizar el trabajo entre diferentes equipos y tambi칠n para poder ampliar de cara al futuro dicha librer칤a, y el mantenimiento se puede volver m치s complejo.</p>
<p>Para resolver todo esto, <strong>vamos a utilizar plugins</strong>.</p>
<h3>Qu칠 entendemos por plugins:</h3>
<p>Por ahora, vamos a considerar <strong>plugin</strong> como <em>un componente de c칩digo, en forma de clase, que posee una interfaz com칰n con otros componentes de c칩digo y realiza una funci칩n similar a estos</em>. Es una definici칩n un poco rara o rebuscada, y seguramente poco acad칠mica, pero que nos vendr치 bien.</p>
<h3>Preparando el plugin</h3>
<p>Para poder usar el plugin, necesitaremos:</p>
<ul>
<li><strong>Buscar los plugins</strong></li>
<li><strong>Seleccionar el plugin</strong></li>
<li><strong>Programar el plugin</strong></li>
</ul>
<h4>Busqueda de plugins.</h4>
<p>Hay varias formas de buscar autom치ticamente los plugins disponibles. Nosotros vamos a centrarnos en el uso de los <em>paquetes de espacios de nombre</em> o <strong>namespace packages</strong>. Para ello, debemos de usar las librer칤as <strong>importlib</strong> y <strong>pkgutil</strong>.</p>
<p>El procedimiento es sencillo: supongamos que hemos creado un paquete con nuestro plugin, y ese paquete est치 usando un espacio de nombres vacio, por ejemplo <em>graficas.plugins</em>. Usando <strong>importlib</strong> y <strong>pkgutil</strong>, lo que vamos a hacer es buscar en ese espacio de nombres todos los m칩dulos que existan. La ventaja es que ese <em>espacio de nombre</em> puede ser compartido y poblado por diferentes librer칤as, las cuales pueden a침adir sus propios m칩dulos que cuelgan debajo de <em>graficas.plugins</em>:</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">pkgutil</span>

<span class="kn">import</span> <span class="nn">graficas.plugins</span>

<span class="k">def</span> <span class="nf">iter_namespace</span><span class="p">(</span><span class="n">ns_pkg</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">pkgutil</span><span class="o">.</span><span class="n">iter_modules</span><span class="p">(</span><span class="n">ns_pkg</span><span class="o">.</span><span class="n">__path__</span><span class="p">,</span> <span class="n">ns</span><span class="o">.</span><span class="n">pkg</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>


<span class="n">discovered_plugins</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">finder</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ispkg</span>
    <span class="ow">in</span> <span class="n">iter_namespace</span><span class="p">(</span><span class="n">graficas</span><span class="o">.</span><span class="n">plugins</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>Pero esto s칩lo nos soluciona una parte del problema, porque lo que hemos recuperado son los m칩dulos, no las clases. Para poder recuperar las clases, necesitamos revisar los m칩dulos y recuperar dichas clases, lo cual podemos hacer usando la librer칤a <strong>inspect</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">inspect</span>

<span class="n">listado_plugins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">module</span> <span class="ow">in</span> <span class="n">discovered_plugins</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="c1">#Cuidado, ya que getmembers devuelve una tupla de dos elementos</span>
    <span class="n">listado_plugins</span> <span class="o">+=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">)</span>
</code></pre></div>

<p>De esta forma, podremos recuperar todas las clases que haya en los m칩dulos recuperados, las cuales deben de ser los plugins. Este c칩digo se puede ampliar, por ejemplo, para que s칩lo recupere ciertas clases, o recupere 칰nicamente funciones, pero cualquiera de estas operaciones deber칤a de realizarse usando <strong>mecanismos de reflexi칩n</strong>.</p>
<h4>Seleccionar el plugin</h4>
<p>Record치is lo que dec칤amos antes, de que un plugin debe de contar con una interfaz com칰n al resto de plugins? Es en esta interfaz donde podemos a침adir informaci칩n sobre nuestro plugin, la cual nos permita realizar una seleccion. Si programamos <strong>m칠todos de clase</strong> que nos proporcionen esa informaci칩n, podemos consultarlos a trav칠s del listado de plugins y seleccionar el correcto:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">MiNuevoPlugin</span><span class="p">(</span><span class="n">PluginBase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_init</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data_init</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">nombre_plugin</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;MiNuevoPlugin&#39;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">formatos_soportados</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;xlsx&#39;</span><span class="p">,</span><span class="s1">&#39;csv&#39;</span><span class="p">]</span>
</code></pre></div>

<p>Este seria el proceso por el cual podemos recuperar nuestros plugins consultando estos datos:</p>
<div class="highlight"><pre><span></span><code><span class="n">plugins_soportados</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">listado_plugins</span> <span class="k">if</span> <span class="s1">&#39;xlsx&#39;</span> <span class="ow">in</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">formatos_soportados</span><span class="p">()]</span>

<span class="c1">#Tambien por nombre</span>
<span class="n">plugin_por_nombre</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">listado_plugins</span> <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">nombre_plugin</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;MiNuevoPlugin&#39;</span><span class="p">),</span><span class="kc">None</span><span class="p">)</span>
</code></pre></div>

<p>Podemos ampliar estos m칠todos de clase para que proporcionen cualquier informaci칩n relevante que necesitemos para seleccionar nuestros plugins.</p>
<h4>Programar el plugin</h4>
<p>Ya hemos adelantado mucho sobre lo que requiere el programar nuestro plugin. Por un lado, hemos visto que necestiamos una <strong>clase base</strong>. Esto no es imprescindible, podemos hacerlo sin una clase base, pero debemos de cuidar que <strong>todos los plugins deben de compartir parte de la interfaz</strong>, y la forma m치s sencilla de hacer esto es empleando <em>herencia de clases</em> y, en mi caso y porque soy as칤 de especial, utilizo tambi칠n <em>clases abstractas</em> para ello.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>

<span class="k">class</span> <span class="nc">PluginBase</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data_init</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_init</span> <span class="o">=</span> <span class="n">data_init</span> <span class="c1">#Datos de inicializaci칩n, puedes usar args y kwargs si quieres, pero voy con prisa :D</span>

<span class="nd">@classmethod</span>
<span class="nd">@abstractmethod</span>
<span class="k">def</span> <span class="nf">nombre_plugin</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@classmethod</span>
<span class="nd">@abstractmethod</span>
<span class="k">def</span> <span class="nf">formatos_soportados</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@abstractmethod</span>
<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>
</code></pre></div>

<p>Esto deber칤a de ser suficiente paraa nuestra clase base. As칤, obligamos a que todos los plugins que compartan esta interfaz implementen los m칠todos de <em>nombre_plugin</em>, <em>formatos_soportados</em> y <em>run</em>, donde pondr칤amos el grueso de nuestro c칩digo.</p>
<h3>Empaquetar y distribuir.</h3>
<p>En mi caso, me gusta que el c칩digo de selecci칩n de plugins est칠 en el proyecto principal, y colocar cada plugin en una librer칤a diferente; igualmente, tengo una librer칤a adicional aparte de los plugins donde tengo programado el plugin base con la interfaz que debe de implementar cada plugin.</p>
<p>A la hora de programar estos paquetes, utilizo <strong>poetry</strong> para ello. Se puede hacer tambi칠n con <em>setup.py</em>, o con otros empaquetadores, pero ya estoy acostumbrado a usar <strong>poetry</strong>.</p>
<p>Para ello, debemos de modificar ligeramente la estructura que nos genera poetry: si nuestro proyecto se llama <em>graficas-plugins-mysql</em>, nos crear치 una carpeta llamada <em>graficas-plugins-mysql</em>, en la cual tendremos nuestro c칩digo y nuestro m칩dulo. Debemos de bajar ese m칩dulo un nivel, renombrando la carpeta superior como <em>graficas-plugins</em> y creando una nueva carpeta <em>mysql</em> dentro de esa carpeta. Y dejar <em>graficas-plugins</em> vac칤a. Luego, ajustar el c칩digo y modificar el archivo <em>pyproject.toml</em> de esta manera: </p>
<div class="highlight"><pre><span></span><code><span class="k">[tool.poetry]</span>
<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;graficas-plugins-mysql&quot;</span>
<span class="n">version</span> <span class="o">=</span> <span class="s">&quot;0.0.1&quot;</span>
<span class="n">description</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
<span class="n">authors</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;bletter &lt;aramirez@letteringenieros.es&gt;&quot;</span><span class="p">]</span>
<span class="n">packages</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span> <span class="n">include</span> <span class="o">=</span> <span class="s">&quot;graficas_plugins/mysql&quot;</span> <span class="p">}</span>
<span class="p">]</span>
</code></pre></div>

<p>De esta forma, estaremos creando un <strong>namespace package</strong> en toda regla. S칩lo tenemos que ajustar el resto del c칩digo para que no nos falle, y ya tendr칤amos funcionando un esquema de plugins.</p>
<h3>Ventajas:</h3>
<ul>
<li>Es m치s f치cil de mantener y ampliar.</li>
<li>Permite paralelizar el trabajo entre diferentes equipos de desarrollo.</li>
<li>Mejora la distribuci칩n del c칩digo, si en diferentes m치quinas es necesario que haya diferentes versiones de la librer칤a para atender las necesidades de diferentes clientes.</li>
</ul>
<h3>Inconvenientes:</h3>
<ul>
<li>Requiere de una planificaci칩n previa, para elaborar la interfaz com칰n</li>
<li>Infraestructura para distribuir correctamente el c칩digo.</li>
<li>Para un 칰nico equipo o equipos muy peque침os, puede resultar demasiado engorroso.</li>
</ul>
	</div>
</article>
			</div>
		</section>
		
<footer class="footer">
    <div class="container has-text-centered">
        <div class="columns">
            <div class="column">
                    Made with 仇벒잺 using Python from Granada. Under construction 游뚾
            </div>
            <div class="column">
                    <img src="https://img.shields.io/badge/License-CC%20BY--NC%204.0-lightgrey.svg" alt="License: CC BY-NC 4.0">
        </div>
    </div>
</footer>
	</body>
</html>